package ner.annotation;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;

/**
 * An object representing token information. It contains an entity tag
 * as well as all sub-tokens (tokens which are within this token's text).
 * EntityAnnotation are meant to be generated by NER techniques, then reconciled with
 * their subTokenAnnotation to create a flat partition of an input.
 * @author aaulabaugh@gmail.com
 */

public class EntityAnnotation implements Comparator<EntityAnnotation>, Comparable<EntityAnnotation>, java.io.Serializable
{
	/**
	 * default serial version UID
	 */
	private static final long serialVersionUID = 1L;

	//All tokens within this token's text
	private transient ArrayList<EntityAnnotation> subTokenAnnotation;
	
	//The text value of the token
	private String content;
	
	private String[] contentTokens;
	
	//The location of the token
	private int beginOffset;
	
	//The NER technique which generated this token
	private String source;
	
	//The entity categories of this token
	private ArrayList<EntityType> entityTypes;
	
	//This term is the termNum-th in the input text
	private int termNum;
	
	//The number of times this token has been loaded into the index
	private transient int indexedCount;
	
	public EntityAnnotation()
	{
		subTokenAnnotation = new ArrayList<EntityAnnotation>();
		content = null;
		beginOffset = -1;
		source = null;
		entityTypes = new ArrayList<EntityType>();
		termNum = -1;
		indexedCount = 0;
	}
	
	public EntityAnnotation clone()
	{
		EntityAnnotation myClone = new EntityAnnotation();
		myClone.content = this.content;
		myClone.contentTokens = this.contentTokens;
		myClone.beginOffset = this.beginOffset;
		myClone.source = this.source;
		myClone.termNum = this.termNum;
		myClone.indexedCount = this.indexedCount;
		
		myClone.entityTypes = new ArrayList<EntityType>();
		for(EntityType type : this.entityTypes)
		{
			myClone.entityTypes.add(type.clone());
		}
		
		myClone.subTokenAnnotation = new ArrayList<EntityAnnotation>();
		for(EntityAnnotation annotation : this.subTokenAnnotation)
		{
			myClone.subTokenAnnotation.add(annotation.clone());
		}
		
		return myClone;
	}
	
	/**
	 * Adds an EntityAnnotation to subTokenAnnotation in the correct place so
	 * "larger tokens on top" is preserved.
	 * @param newAnnotation
	 */
	public void addAnnotation(EntityAnnotation newAnnotation)
	{
		boolean added = false;
		if(isEqualToken(newAnnotation))
		{
			subTokenAnnotation.add(newAnnotation);
			added = true;
		}
		else
		{
			for(EntityAnnotation subAnnotation : subTokenAnnotation)
			{
				if(subAnnotation.isSuperToken(newAnnotation) && !added)
				{
					subAnnotation.addAnnotation(newAnnotation);
					added = true;
				}
			}
			if(!added)
			{
				subTokenAnnotation.add(newAnnotation);
				added = true;
			}
		}
	}
	
	public int getIndexedCount()
	{
		return indexedCount;
	}
	
	public HashMap<String, String> getThisIterationInformation()
	{
		HashMap<String, String> outputInfo = new HashMap<String, String>();
		if(indexedCount % (contentTokens.length+1) == 0 || contentTokens.length == 1)
			outputInfo.put("token", content);
		else
			outputInfo.put("token", contentTokens[(indexedCount % (contentTokens.length+1))-1]);
		int typeNum = indexedCount / (contentTokens.length+1);
		if(typeNum < entityTypes.size())
			outputInfo.put("type", entityTypes.get(typeNum).getID());
		else
			outputInfo.put("type", "O");
		int currentOffset = beginOffset;
		for(int i = 0; i < (indexedCount % (contentTokens.length+1))-1; i++)
			currentOffset += contentTokens[i].length() + 1;
		outputInfo.put("offset", Integer.toString(currentOffset));
		indexedCount++;
		return outputInfo;
	}
	
	/**
	 * @return the appropriate entity type for this iteration of indexing
	 */
	public String getThisIterationType()
	{			
		if(indexedCount < entityTypes.size())
		{
			String type = entityTypes.get(indexedCount).getID();
			indexedCount++;
			return type;
		}
		indexedCount++;
		return "O";
	}
	
	/**
	 * @return true iff this annotation has been indexed the appropriate number
	 * of times
	 */
	public boolean isFullyIndexed()
	{
		if(contentTokens.length == 1)
			return indexedCount >= (Math.max(entityTypes.size() + 1, 1)*(contentTokens.length));
		else
			return indexedCount >= (Math.max(entityTypes.size() + 1, 1)*(contentTokens.length+1));
	}
	
	/**
	 * Removes all entity types
	 */
	public void clearTypes()
	{
		entityTypes = new ArrayList<EntityType>();
	}
	
	/**
	 * Resets all subAnnotations
	 */
	public void clearSubAnnotation()
	{
		subTokenAnnotation = new ArrayList<EntityAnnotation>();
	}
	
	public void setContent(String str)
	{
		content = str;
		contentTokens = content.split(" ");
	}
	
	public void setPosition(int offset)
	{
		beginOffset = offset;
	}
	
	public void setSource(String src)
	{
		source = src;
	}
	
	public void addType(EntityType type)
	{
		entityTypes.add(type);
	}
	
	public void setTypes(ArrayList<EntityType> types)
	{
		entityTypes = types;
	}
	
	public void setTermNum(int num)
	{
		termNum = num;
	}
	
	public ArrayList<EntityAnnotation> getChildren()
	{
		return subTokenAnnotation;
	}
	
	public String getContent()
	{
		return content;
	}
	
	public int getPosition()
	{
		return beginOffset;
	}
	
	public String getSource()
	{
		return source;
	}
	
	public ArrayList<EntityType> getTypes()
	{
		return entityTypes;
	}
	
	public int getTermNum()
	{
		return termNum;
	}
	
	/**
	 * True if this EntityAnnotation encapsulates or is equal to the other
	 * @param other
	 * @return
	 */
	public boolean isSuperToken(EntityAnnotation other)
	{
		int otherStart = other.getPosition();
		int otherEnd = otherStart + other.getContent().length();
		return otherStart >= beginOffset && otherEnd <= (beginOffset + content.length());
	}
	
	public String toString()
	{
		String typesString = "";
		for(EntityType t : entityTypes)
		{
			typesString = typesString + t.getID() + "-";
		}
		if(typesString.length() > 0)
			typesString = typesString.substring(0, typesString.length()-1);
		return "<" + String.join(", ", content, Integer.toString(beginOffset), source, typesString) + ">";
	}
	
	/**
	 * True iff this EntityAnnotation's content and position exactly match the other's.
	 * @param other
	 * @return
	 */
	public boolean isEqualToken(EntityAnnotation other)
	{
		return (other.getContent().equals(content) && other.getPosition()== beginOffset);
	}

	@Override
	public int compareTo(EntityAnnotation o)
	{
		return beginOffset - o.beginOffset;
	}

	@Override
	public int compare(EntityAnnotation o1, EntityAnnotation o2)
	{
		return o1.beginOffset - o2.beginOffset;
	}

}
